{"schemaVersion":{"minor":3,"major":0,"patch":0},"identifier":{"url":"doc:\/\/Bitcoin\/documentation\/Bitcoin\/GettingStarted","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"To start using Swift Bitcoin just add it as a dependency to your package manifest."}],"seeAlsoSections":[{"generated":true,"title":"Essentials","identifiers":["doc:\/\/Bitcoin\/documentation\/Bitcoin\/BitcoinTransaction"]}],"sections":[],"kind":"article","variants":[{"paths":["\/documentation\/bitcoin\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"roleHeading":"Article","title":"Getting Started","modules":[{"name":"Swift Bitcoin"}],"role":"article"},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"anchor":"Preparation","text":"Preparation"},{"type":"heading","anchor":"Add-the-package","level":3,"text":"Add the package"},{"type":"paragraph","inlineContent":[{"text":"In your ","type":"text"},{"type":"codeVoice","code":"Package.swift"},{"type":"text","text":" dependencies add the package’s URL "},{"identifier":"https:\/\/github.com\/swift-bitcoin\/swift-bitcoin","type":"reference","isActive":true},{"type":"text","text":"."}]},{"type":"heading","level":3,"text":"Import the framework","anchor":"Import-the-framework"},{"inlineContent":[{"text":"To begin just import ","type":"text"},{"code":"Bitcoin","type":"codeVoice"},{"text":".","type":"text"}],"type":"paragraph"},{"code":["import Bitcoin"],"type":"codeListing","syntax":"swift"},{"anchor":"Mine-a-transaction","text":"Mine a transaction","level":2,"type":"heading"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example we will spin up a test Bitcoin server and use it to mine a transaction."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s start by generating a key pair and derive an address for our test."}]},{"syntax":"swift","code":["\/\/ Generate a secret key, corresponding public key, hash and address.","let secretKey = Wallet.createSecretKey() as Data","let publicKey = Wallet.getPublicKey(secretKey: secretKey)","let publicKeyHash = hash160(publicKey)","let address = try Wallet.getAddress(publicKey: publicKey, sigVersion: .base, network: .regtest)"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Prepare the Bitcoin service."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["\/\/ Instantiate a fresh Bitcoin service (regtest).","let service = BitcoinService()","","\/\/ Create the genesis block.","await service.createGenesisBlock()","","\/\/ Mine 100 blocks so block 1's coinbase output reaches maturity.","for _ in 0 ..< 100 {","    await service.generateTo(address)","}"]},{"type":"paragraph","inlineContent":[{"text":"Prepare our transaction.","type":"text"}]},{"syntax":"swift","code":["\/\/ Grab block 1's coinbase transaction and output.","let previousTransaction = await service.blockchain[1].transactions[0]","let previousOutput = previousTransaction.outputs[0]","let outpoint = previousTransaction.outpoint(for: 0)!","","\/\/ Create a new transaction spending from the previous transaction's outpoint.","let unsignedInput = TransactionInput(outpoint: outpoint, sequence: .final)","","\/\/ Specify the transaction's output. We'll leave 1000 sats on the table to tip miners. We'll re-use the origin address for simplicity.","let unsignedTransaction = BitcoinTransaction(","    inputs: [unsignedInput],","    outputs: [","        .init(value: 49_99_999_000, script: .init([","            .dup,","            .hash160,","            .pushBytes(publicKeyHash),","            .equalVerify,","            .checkSig","        ]))","    ])"],"type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We now need to sign the transaction using our secret key."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Sign the transaction by first calculating the signature hash.","let sigHash = unsignedTransaction.signatureHash(sighashType: .all, inputIndex: 0, previousOutput: previousOutput, scriptCode: previousOutput.script.data)","","\/\/ Obtain the signature using our secret key and append the signature hash type.","let sig = signECDSA(message: sigHash, secretKey: secretKey) + [SighashType.all.value]","","\/\/ Sign our input by including the signature and public key.","let signedInput = TransactionInput(","    outpoint: unsignedInput.outpoint,","    sequence: unsignedInput.sequence,","    script: .init([","        .pushBytes(sig),","        .pushBytes(publicKey)","    ]),","    witness: unsignedInput.witness)","","\/\/ Put the signed input back into the transaction.","let signedTransaction = BitcoinTransaction(","    version: unsignedTransaction.version,","    locktime: unsignedTransaction.locktime,","    inputs: [signedInput],","    outputs: unsignedTransaction.outputs)"]},{"type":"paragraph","inlineContent":[{"text":"We can verify that the transaction was signed correctly.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Make sure the transaction was signed correctly by verifying the scripts.","if signedTransaction.verifyScript(previousOutputs: [previousOutput]) {","    \/\/ Yay! Our transaction is valid.","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now we’re ready to submit our signed transaction to the mempool."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Submit the signed transaction to the mempool.","await service.addTransaction(signedTransaction)","","\/\/ The mempool should now contain our transaction.","let mempoolBefore = await service.mempool.count \/\/ 1"]},{"type":"paragraph","inlineContent":[{"text":"After confirming the transaction was accepted we can mine a block and get it confirmed.","type":"text"}]},{"code":["\/\/ Let's mine another block to confirm our transaction.","await service.generateTo(address)","","\/\/ The mempool should now be empty.","let mempoolAfter = await service.mempool.count \/\/ 0"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"text":"Finally let’s make sure the transaction was confirmed in a block.","type":"text"}]},{"code":["let blocks = await service.blockchain.count \/\/ 102","","let lastBlock = await service.blockchain.last!","\/\/ Verify our transaction was confirmed in a block.","if lastBlock.transactions[1] == signedTransaction {","    \/\/ Our transaction is now confirmed in the blockchain!","}"],"syntax":"swift","type":"codeListing"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We have effectively recreated the entire transaction lifecycle."}]}]}],"hierarchy":{"paths":[["doc:\/\/Bitcoin\/documentation\/Bitcoin"]]},"references":{"https://github.com/swift-bitcoin/swift-bitcoin":{"identifier":"https:\/\/github.com\/swift-bitcoin\/swift-bitcoin","url":"https:\/\/github.com\/swift-bitcoin\/swift-bitcoin","titleInlineContent":[{"text":"https:\/\/github.com\/swift-bitcoin\/swift-bitcoin","type":"text"}],"type":"link","title":"https:\/\/github.com\/swift-bitcoin\/swift-bitcoin"},"doc://Bitcoin/documentation/Bitcoin":{"type":"topic","url":"\/documentation\/bitcoin","kind":"symbol","role":"collection","identifier":"doc:\/\/Bitcoin\/documentation\/Bitcoin","title":"Swift Bitcoin","abstract":[{"text":"Pure-Swift Bitcoin client implementation with full node capabilities.","type":"text"}]},"doc://Bitcoin/documentation/Bitcoin/BitcoinTransaction":{"fragments":[{"text":"struct","kind":"keyword"},{"kind":"text","text":" "},{"kind":"identifier","text":"BitcoinTransaction"}],"navigatorTitle":[{"kind":"identifier","text":"BitcoinTransaction"}],"kind":"symbol","url":"\/documentation\/bitcoin\/bitcointransaction","type":"topic","identifier":"doc:\/\/Bitcoin\/documentation\/Bitcoin\/BitcoinTransaction","title":"BitcoinTransaction","abstract":[{"type":"text","text":"A Bitcoin transaction."}],"role":"symbol"}}}