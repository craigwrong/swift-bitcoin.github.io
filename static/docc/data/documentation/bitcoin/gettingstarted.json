{"hierarchy":{"paths":[["doc:\/\/Bitcoin\/documentation\/Bitcoin"]]},"sections":[],"kind":"article","abstract":[{"type":"text","text":"To start using Swift Bitcoin just add it as a dependency to your package manifest."}],"primaryContentSections":[{"content":[{"text":"Preparation","type":"heading","level":2,"anchor":"Preparation"},{"text":"Add the package","level":3,"type":"heading","anchor":"Add-the-package"},{"type":"paragraph","inlineContent":[{"text":"In your ","type":"text"},{"code":"Package.swift","type":"codeVoice"},{"type":"text","text":" dependencies add the package’s URL "},{"type":"codeVoice","code":"https:\/\/github.com\/swift-bitcoin\/swift-bitcoin"},{"text":".","type":"text"}]},{"level":3,"text":"Import the framework","anchor":"Import-the-framework","type":"heading"},{"inlineContent":[{"type":"text","text":"To begin just import "},{"type":"codeVoice","code":"Bitcoin"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","type":"codeListing","code":["import Bitcoin"]},{"text":"Mine a transaction","type":"heading","level":2,"anchor":"Mine-a-transaction"},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example we will spin up a test Bitcoin server and use it to mine a transaction."}]},{"inlineContent":[{"type":"text","text":"Let’s start by generating a key pair and derive an address for our test."}],"type":"paragraph"},{"code":["\/\/ Generate a secret key, corresponding public key, hash and address.","let secretKey = SecretKey()","let publicKey = secretKey.publicKey","let publicKeyHash = hash160(publicKey.data)","let address = try Wallet.getAddress(publicKey: publicKey, sigVersion: .base, network: .regtest)"],"type":"codeListing","syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Prepare the Bitcoin service.","type":"text"}]},{"type":"codeListing","code":["\/\/ Instantiate a fresh Bitcoin service (regtest).","let service = BitcoinService()","","\/\/ Create the genesis block.","await service.createGenesisBlock()","","\/\/ Mine 100 blocks so block 1's coinbase output reaches maturity.","for _ in 0 ..< 100 {","    await service.generateTo(publicKey)","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Prepare our transaction."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Grab block 1's coinbase transaction and output.","let previousTransaction = await service.blockTransactions[1][0]","let previousOutput = previousTransaction.outputs[0]","let outpoint = previousTransaction.outpoint(for: 0)!","","\/\/ Create a new transaction spending from the previous transaction's outpoint.","let unsignedInput = TransactionInput(outpoint: outpoint, sequence: .final)","","\/\/ Specify the transaction's output. We'll leave 1000 sats on the table to tip miners. We'll re-use the origin address for simplicity.","let unsignedTransaction = BitcoinTransaction(","    inputs: [unsignedInput],","    outputs: [","        .init(value: 49_99_999_000, script: .init([","            .dup,","            .hash160,","            .pushBytes(publicKeyHash),","            .equalVerify,","            .checkSig","        ]))","    ])"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We now need to sign the transaction using our secret key."}]},{"code":["\/\/ Sign the transaction by first calculating the signature hash.","let sigHash = unsignedTransaction.signatureHash(sighashType: .all, inputIndex: 0, previousOutput: previousOutput, scriptCode: previousOutput.script.data)","","\/\/ Obtain the signature using our secret key and append the signature hash type.","let signature = Signature(messageHash: sigHash, secretKey: secretKey, type: .ecdsa)","let signatureData = signature.data + [SighashType.all.value]","","\/\/ Sign our input by including the signature and public key.","let signedInput = TransactionInput(","    outpoint: unsignedInput.outpoint,","    sequence: unsignedInput.sequence,","    script: .init([","        .pushBytes(signatureData),","        .pushBytes(publicKey.data)","    ]),","    witness: unsignedInput.witness)","","\/\/ Put the signed input back into the transaction.","let signedTransaction = BitcoinTransaction(","    version: unsignedTransaction.version,","    locktime: unsignedTransaction.locktime,","    inputs: [signedInput],","    outputs: unsignedTransaction.outputs)"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"type":"text","text":"We can verify that the transaction was signed correctly."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Make sure the transaction was signed correctly by verifying the scripts.","let isVerified = signedTransaction.verifyScript(previousOutputs: [previousOutput])","","#expect(isVerified)","\/\/ Yay! Our transaction is valid."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now we’re ready to submit our signed transaction to the mempool."}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Submit the signed transaction to the mempool.","await service.addTransaction(signedTransaction)","","\/\/ The mempool should now contain our transaction.","let mempoolBefore = await service.mempool.count","#expect(mempoolBefore == 1)"]},{"inlineContent":[{"type":"text","text":"After confirming the transaction was accepted we can mine a block and get it confirmed."}],"type":"paragraph"},{"type":"codeListing","syntax":"swift","code":["\/\/ Let's mine another block to confirm our transaction.","","\/\/ In this case we can use the address we created before.","","\/\/ Decode the address to get the public key hash.","let decodedPublicKeyHash = Base58Decoder().decode(address)!.dropFirst()","#expect(publicKeyHash == decodedPublicKeyHash)","","\/\/ Minde to the public key hash","await service.generateTo(decodedPublicKeyHash)","","\/\/ The mempool should now be empty.","let mempoolAfter = await service.mempool.count","#expect(mempoolAfter == 0)"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally let’s make sure the transaction was confirmed in a block."}]},{"syntax":"swift","code":["let blocks = await service.headers.count","#expect(blocks == 102)","","let lastBlock = await service.blockTransactions.last!","\/\/ Verify our transaction was confirmed in a block.","","#expect(lastBlock[1] == signedTransaction)","\/\/ Our transaction is now confirmed in the blockchain!"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"We have effectively recreated the entire transaction lifecycle."}],"type":"paragraph"}],"kind":"content"}],"schemaVersion":{"minor":3,"major":0,"patch":0},"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/bitcoin\/gettingstarted"]}],"identifier":{"url":"doc:\/\/Bitcoin\/documentation\/Bitcoin\/GettingStarted","interfaceLanguage":"swift"},"metadata":{"roleHeading":"Article","modules":[{"name":"Swift Bitcoin"}],"role":"article","title":"Getting Started"},"references":{"doc://Bitcoin/documentation/Bitcoin":{"kind":"symbol","identifier":"doc:\/\/Bitcoin\/documentation\/Bitcoin","abstract":[{"type":"text","text":"Pure-Swift Bitcoin client implementation with full node capabilities."}],"url":"\/documentation\/bitcoin","type":"topic","title":"Swift Bitcoin","role":"collection"}}}